"use strict";(self.webpackChunkcosmos_sdk_docs=self.webpackChunkcosmos_sdk_docs||[]).push([[88968],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=o,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||a;return n?r.createElement(h,i(i({ref:t},p),{},{components:n})):r.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},94294:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var r=n(87462),o=(n(67294),n(3905));const a={},i="Implementing Vote Extensions",s={unversionedId:"tutorials/vote-extensions/oracle/implementing-vote-extensions",id:"tutorials/vote-extensions/oracle/implementing-vote-extensions",title:"Implementing Vote Extensions",description:"Implement ExtendVote",source:"@site/docs/tutorials/vote-extensions/oracle/02-implementing-vote-extensions.md",sourceDirName:"tutorials/vote-extensions/oracle",slug:"/tutorials/vote-extensions/oracle/implementing-vote-extensions",permalink:"/main/tutorials/vote-extensions/oracle/implementing-vote-extensions",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialsSidebar",previous:{title:"What is an Oracle?",permalink:"/main/tutorials/vote-extensions/oracle/what-is-an-oracle"},next:{title:"Testing the Oracle Module",permalink:"/main/tutorials/vote-extensions/oracle/testing-oracle"}},l={},c=[{value:"Implement ExtendVote",id:"implement-extendvote",level:2},{value:"Implement PrepareProposal",id:"implement-prepareproposal",level:2},{value:"Implement ProcessProposal",id:"implement-processproposal",level:2},{value:"Implement PreBlocker",id:"implement-preblocker",level:2},{value:"Conclusion",id:"conclusion",level:2}],p={toc:c},d="wrapper";function u(e){let{components:t,...n}=e;return(0,o.kt)(d,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"implementing-vote-extensions"},"Implementing Vote Extensions"),(0,o.kt)("h2",{id:"implement-extendvote"},"Implement ExtendVote"),(0,o.kt)("p",null,"First we\u2019ll create the ",(0,o.kt)("inlineCode",{parentName:"p"},"OracleVoteExtension")," struct, this is the object that will be marshaled as bytes and signed by the validator."),(0,o.kt)("p",null,"In our example we\u2019ll use JSON to marshal the vote extension for simplicity but we recommend to find an encoding that produces a smaller output, given that large vote extensions could impact CometBFT\u2019s performance. Custom encodings and compressed bytes can be used out of the box."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// OracleVoteExtension defines the canonical vote extension structure.\ntype OracleVoteExtension struct {\n Height int64\n Prices map[string]math.LegacyDec\n}\n")),(0,o.kt)("p",null,"Then we\u2019ll create a ",(0,o.kt)("inlineCode",{parentName:"p"},"VoteExtensionsHandler")," struct that contains everything we need to query for prices."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"type VoteExtHandler struct {\n logger          log.Logger\n currentBlock    int64                            // current block height\n lastPriceSyncTS time.Time                        // last time we synced prices\n providerTimeout time.Duration                    // timeout for fetching prices from providers\n providers       map[string]Provider              // mapping of provider name to provider (e.g. Binance -> BinanceProvider)\n providerPairs   map[string][]keeper.CurrencyPair // mapping of provider name to supported pairs (e.g. Binance -> [ATOM/USD])\n\n Keeper keeper.Keeper // keeper of our oracle module\n}\n")),(0,o.kt)("p",null,"Finally, a function that returns ",(0,o.kt)("inlineCode",{parentName:"p"},"sdk.ExtendVoteHandler")," is needed too, and this is where our vote extension logic will live."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'func (h *VoteExtHandler) ExtendVoteHandler() sdk.ExtendVoteHandler {\n    return func(ctx sdk.Context, req *abci.RequestExtendVote) (*abci.ResponseExtendVote, error) {\n        // here we\'d have a helper function that gets all the prices and does a weighted average using the volume of each market\n        prices := h.getAllVolumeWeightedPrices()\n\n        voteExt := OracleVoteExtension{\n            Height: req.Height,\n            Prices: prices,\n        }\n        \n        bz, err := json.Marshal(voteExt)\n        if err != nil {\n            return nil, fmt.Errorf("failed to marshal vote extension: %w", err)\n        }\n\n        return &abci.ResponseExtendVote{VoteExtension: bz}, nil\n    }\n}\n')),(0,o.kt)("p",null,"As you can see above, the creation of a vote extension is pretty simple and we just have to return bytes. CometBFT will handle the signing of these bytes for us. We ignored the process of getting the prices but you can see a more complete example ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/cosmos/sdk-tutorials/blob/master/tutorials/oracle/base/x/oracle/abci/vote_extensions.go"},"here:")),(0,o.kt)("p",null,"Here we\u2019ll do some simple checks like:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Is the vote extension unmarshaled correctly?"),(0,o.kt)("li",{parentName:"ul"},"Is the vote extension for the right height?"),(0,o.kt)("li",{parentName:"ul"},"Some other validation, for example, are the prices from this extension too deviated from my own prices? Or maybe checks that can detect malicious behavior.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'func (h *VoteExtHandler) VerifyVoteExtensionHandler() sdk.VerifyVoteExtensionHandler {\n    return func(ctx sdk.Context, req *abci.RequestVerifyVoteExtension) (*abci.ResponseVerifyVoteExtension, error) {\n        var voteExt OracleVoteExtension\n        err := json.Unmarshal(req.VoteExtension, &voteExt)\n        if err != nil {\n            return nil, fmt.Errorf("failed to unmarshal vote extension: %w", err)\n        }\n        \n        if voteExt.Height != req.Height {\n            return nil, fmt.Errorf("vote extension height does not match request height; expected: %d, got: %d", req.Height, voteExt.Height)\n        }\n\n        // Verify incoming prices from a validator are valid. Note, verification during\n        // VerifyVoteExtensionHandler MUST be deterministic. For brevity and demo\n        // purposes, we omit implementation.\n        if err := h.verifyOraclePrices(ctx, voteExt.Prices); err != nil {\n            return nil, fmt.Errorf("failed to verify oracle prices from validator %X: %w", req.ValidatorAddress, err)\n        }\n\n        return &abci.ResponseVerifyVoteExtension{Status: abci.ResponseVerifyVoteExtension_ACCEPT}, nil\n    }\n}\n')),(0,o.kt)("h2",{id:"implement-prepareproposal"},"Implement PrepareProposal"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"type ProposalHandler struct {\n    logger   log.Logger\n    keeper   keeper.Keeper // our oracle module keeper\n    valStore baseapp.ValidatorStore // to get the current validators' pubkeys\n}\n")),(0,o.kt)("p",null,"And we create the struct for our \u201cspecial tx\u201d, that will contain the prices and the votes so validators can later re-check in ProcessPRoposal that they get the same result than the block\u2019s proposer. With this we could also check if all the votes have been used by comparing the votes received in ProcessProposal."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"type StakeWeightedPrices struct {\n    StakeWeightedPrices map[string]math.LegacyDec\n    ExtendedCommitInfo  abci.ExtendedCommitInfo\n}\n")),(0,o.kt)("p",null,"Now we create the ",(0,o.kt)("inlineCode",{parentName:"p"},"PrepareProposalHandler"),". In this step we\u2019ll first check if the vote extensions\u2019 signatures are correct using a helper function called ValidateVoteExtensions from the baseapp package."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"func (h *ProposalHandler) PrepareProposal() sdk.PrepareProposalHandler {\n    return func(ctx sdk.Context, req *abci.RequestPrepareProposal) (*abci.ResponsePrepareProposal, error) {\n        err := baseapp.ValidateVoteExtensions(ctx, h.valStore, req.Height, ctx.ChainID(), req.LocalLastCommit)\n        if err != nil {\n            return nil, err\n        }\n...\n")),(0,o.kt)("p",null,"Then we proceed to make the calculations only if the current height if higher than the height at which vote extensions have been enabled. Remember that vote extensions are made available to the block proposer on the next block at which they are produced/enabled."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'...\n        proposalTxs := req.Txs\n\n        if req.Height > ctx.ConsensusParams().Abci.VoteExtensionsEnableHeight {\n            stakeWeightedPrices, err := h.computeStakeWeightedOraclePrices(ctx, req.LocalLastCommit)\n            if err != nil {\n                return nil, errors.New("failed to compute stake-weighted oracle prices")\n            }\n\n            injectedVoteExtTx := StakeWeightedPrices{\n                StakeWeightedPrices: stakeWeightedPrices,\n                ExtendedCommitInfo:  req.LocalLastCommit,\n            }\n...\n')),(0,o.kt)("p",null,"Finally we inject the result as a transaction at a specific location, usually at the beginning of the block:"),(0,o.kt)("h2",{id:"implement-processproposal"},"Implement ProcessProposal"),(0,o.kt)("p",null,"Now we can implement the method that all validators will execute to ensure the proposer is doing his work correctly."),(0,o.kt)("p",null,"Here, if vote extensions are enabled, we\u2019ll check if the tx at index 0 is an injected vote extension"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'func (h *ProposalHandler) ProcessProposal() sdk.ProcessProposalHandler {\n    return func(ctx sdk.Context, req *abci.RequestProcessProposal) (*abci.ResponseProcessProposal, error) {\n        if req.Height > ctx.ConsensusParams().Abci.VoteExtensionsEnableHeight {\n            var injectedVoteExtTx StakeWeightedPrices\n            if err := json.Unmarshal(req.Txs[0], &injectedVoteExtTx); err != nil {\n                h.logger.Error("failed to decode injected vote extension tx", "err", err)\n                return &abci.ResponseProcessProposal{Status: abci.ResponseProcessProposal_REJECT}, nil\n            }\n...\n')),(0,o.kt)("p",null,"Then we re-validate the vote extensions signatures using\nbaseapp.ValidateVoteExtensions, re-calculate the results (just like in PrepareProposal) and compare them with the results we got from the injected tx."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"            err := baseapp.ValidateVoteExtensions(ctx, h.valStore, req.Height, ctx.ChainID(), injectedVoteExtTx.ExtendedCommitInfo)\n            if err != nil {\n                return nil, err\n            }\n\n            // Verify the proposer's stake-weighted oracle prices by computing the same\n            // calculation and comparing the results. We omit verification for brevity\n            // and demo purposes.\n            stakeWeightedPrices, err := h.computeStakeWeightedOraclePrices(ctx, injectedVoteExtTx.ExtendedCommitInfo)\n            if err != nil {\n                return &abci.ResponseProcessProposal{Status: abci.ResponseProcessProposal_REJECT}, nil\n            }\n            \n            if err := compareOraclePrices(injectedVoteExtTx.StakeWeightedPrices, stakeWeightedPrices); err != nil {\n                return &abci.ResponseProcessProposal{Status: abci.ResponseProcessProposal_REJECT}, nil\n            }\n        }\n\n        return &abci.ResponseProcessProposal{Status: abci.ResponseProcessProposal_ACCEPT}, nil\n    }\n}\n")),(0,o.kt)("p",null,"Important: In this example we avoided using the mempool and other basics, please refer to the DefaultProposalHandler for a complete implementation: ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/blob/v0.50.1/baseapp/abci_utils.go"},"https://github.com/cosmos/cosmos-sdk/blob/v0.50.1/baseapp/abci_utils.go")),(0,o.kt)("h2",{id:"implement-preblocker"},"Implement PreBlocker"),(0,o.kt)("p",null,"Now validators are extending their vote, verifying other votes and including the result in the block. But how do we actually make use of this result? This is done in the PreBlocker which is code that is run before any other code during FinalizeBlock so we make sure we make this information available to the chain and its modules during the entire block execution (from BeginBlock)."),(0,o.kt)("p",null,"At this step we know that the injected tx is well-formatted and has been verified by the validators participating in consensus, so making use of it is straightforward. Just check if vote extensions are enabled, pick up the first transaction and use a method in your module\u2019s keeper to set the result."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'func (h *ProposalHandler) PreBlocker(ctx sdk.Context, req *abci.RequestFinalizeBlock) (*sdk.ResponsePreBlock, error) {\n    res := &sdk.ResponsePreBlock{}\n    if len(req.Txs) == 0 {\n        return res, nil\n    }\n\n    if req.Height > ctx.ConsensusParams().Abci.VoteExtensionsEnableHeight {\n        var injectedVoteExtTx StakeWeightedPrices\n        if err := json.Unmarshal(req.Txs[0], &injectedVoteExtTx); err != nil {\n            h.logger.Error("failed to decode injected vote extension tx", "err", err)\n            return nil, err\n        }\n\n        // set oracle prices using the passed in context, which will make these prices available in the current block\n        if err := h.keeper.SetOraclePrices(ctx, injectedVoteExtTx.StakeWeightedPrices); err != nil {\n            return nil, err\n        }\n    }\n    return res, nil\n}\n\n')),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"In this tutorial, we've created a simple price oracle module that incorporates vote extensions. We've seen how to implement ",(0,o.kt)("inlineCode",{parentName:"p"},"ExtendVote"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"VerifyVoteExtension"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"PrepareProposal"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"ProcessProposal"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"PreBlocker")," to handle the voting and verification process of vote extensions, as well as how to make use of the results during the block execution."))}u.isMDXComponent=!0}}]);