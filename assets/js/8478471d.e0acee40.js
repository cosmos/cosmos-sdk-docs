"use strict";(self.webpackChunkcosmos_sdk_docs=self.webpackChunkcosmos_sdk_docs||[]).push([[67941],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),d=c(n),m=i,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||s;return n?a.createElement(h,o(o({ref:t},p),{},{components:n})):a.createElement(h,o({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=n.length,o=new Array(s);o[0]=m;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[d]="string"==typeof e?e:i,o[1]=r;for(var c=2;c<s;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},62299:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var a=n(87462),i=(n(67294),n(3905));const s={},o="ICS 030: Cosmos Signed Messages",r={unversionedId:"build/spec/ics/ics-030-signed-messages",id:"version-0.47/build/spec/ics/ics-030-signed-messages",title:"ICS 030: Cosmos Signed Messages",description:"TODO: Replace with valid ICS number and possibly move to new location.",source:"@site/versioned_docs/version-0.47/build/spec/ics/ics-030-signed-messages.md",sourceDirName:"build/spec/ics",slug:"/build/spec/ics/ics-030-signed-messages",permalink:"/v0.47/build/spec/ics/ics-030-signed-messages",draft:!1,tags:[],version:"0.47",frontMatter:{},sidebar:"buildSidebar",previous:{title:"Cosmos ICS",permalink:"/v0.47/build/spec/ics/"},next:{title:"Packages",permalink:"/v0.47/build/packages/"}},l={},c=[{value:"Status",id:"status",level:2},{value:"Changelog",id:"changelog",level:2},{value:"Abstract",id:"abstract",level:2},{value:"Preliminary",id:"preliminary",level:2},{value:"Specification",id:"specification",level:2},{value:"Future Adaptations",id:"future-adaptations",level:2},{value:"API",id:"api",level:2},{value:"<strong>cosmosSignBytes</strong>",id:"cosmossignbytes",level:3},{value:"Examples",id:"examples",level:3},{value:"References",id:"references",level:2}],p={toc:c},d="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"ics-030-cosmos-signed-messages"},"ICS 030: Cosmos Signed Messages"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"TODO: Replace with valid ICS number and possibly move to new location.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#changelog"},"Changelog")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#abstract"},"Abstract")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#preliminary"},"Preliminary")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#specification"},"Specification")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#future-adaptations"},"Future Adaptations")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#api"},"API")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#references"},"References"),"  ")),(0,i.kt)("h2",{id:"status"},"Status"),(0,i.kt)("p",null,"Proposed."),(0,i.kt)("h2",{id:"changelog"},"Changelog"),(0,i.kt)("h2",{id:"abstract"},"Abstract"),(0,i.kt)("p",null,"Having the ability to sign messages off-chain has proven to be a fundamental aspect\nof nearly any blockchain. The notion of signing messages off-chain has many\nadded benefits such as saving on computational costs and reducing transaction\nthroughput and overhead. Within the context of the Cosmos, some of the major\napplications of signing such data includes, but is not limited to, providing a\ncryptographic secure and verifiable means of proving validator identity and\npossibly associating it with some other framework or organization. In addition,\nhaving the ability to sign Cosmos messages with a Ledger or similar HSM device."),(0,i.kt)("p",null,"A standardized protocol for hashing, signing, and verifying messages that can be\nimplemented by the Cosmos SDK and other third-party organizations is needed. Such a\nstandardized protocol subscribes to the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Contains a specification of human-readable and machine-verifiable typed structured data"),(0,i.kt)("li",{parentName:"ul"},"Contains a framework for deterministic and injective encoding of structured data"),(0,i.kt)("li",{parentName:"ul"},"Utilizes cryptographic secure hashing and signing algorithms"),(0,i.kt)("li",{parentName:"ul"},"A framework for supporting extensions and domain separation"),(0,i.kt)("li",{parentName:"ul"},"Is invulnerable to chosen ciphertext attacks"),(0,i.kt)("li",{parentName:"ul"},"Has protection against potentially signing transactions a user did not intend to")),(0,i.kt)("p",null,"This specification is only concerned with the rationale and the standardized\nimplementation of Cosmos signed messages. It does ",(0,i.kt)("strong",{parentName:"p"},"not")," concern itself with the\nconcept of replay attacks as that will be left up to the higher-level application\nimplementation. If you view signed messages in the means of authorizing some\naction or data, then such an application would have to either treat this as\nidempotent or have mechanisms in place to reject known signed messages."),(0,i.kt)("h2",{id:"preliminary"},"Preliminary"),(0,i.kt)("p",null,"The Cosmos message signing protocol will be parameterized with a cryptographic\nsecure hashing algorithm ",(0,i.kt)("inlineCode",{parentName:"p"},"SHA-256")," and a signing algorithm ",(0,i.kt)("inlineCode",{parentName:"p"},"S")," that contains\nthe operations ",(0,i.kt)("inlineCode",{parentName:"p"},"sign")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"verify")," which provide a digital signature over a set\nof bytes and verification of a signature respectively."),(0,i.kt)("p",null,"Note, our goal here is not to provide context and reasoning about why necessarily\nthese algorithms were chosen apart from the fact they are the defacto algorithms\nused in CometBFT and the Cosmos SDK and that they satisfy our needs for such\ncryptographic algorithms such as having resistance to collision and second\npre-image attacks, as well as being ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Hash_function#Determinism"},"deterministic")," and ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Hash_function#Uniformity"},"uniform"),"."),(0,i.kt)("h2",{id:"specification"},"Specification"),(0,i.kt)("p",null,"CometBFT has a well established protocol for signing messages using a canonical\nJSON representation as defined ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cometbft/cometbft/blob/master/types/canonical.go"},"here"),"."),(0,i.kt)("p",null,"An example of such a canonical JSON structure is CometBFT's vote structure:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'type CanonicalJSONVote struct {\n    ChainID   string               `json:"@chain_id"`\n    Type      string               `json:"@type"`\n    BlockID   CanonicalJSONBlockID `json:"block_id"`\n    Height    int64                `json:"height"`\n    Round     int                  `json:"round"`\n    Timestamp string               `json:"timestamp"`\n    VoteType  byte                 `json:"type"`\n}\n')),(0,i.kt)("p",null,"With such canonical JSON structures, the specification requires that they include\nmeta fields: ",(0,i.kt)("inlineCode",{parentName:"p"},"@chain_id")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"@type"),". These meta fields are reserved and must be\nincluded. They are both of type ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),". In addition, fields must be ordered\nin lexicographically ascending order."),(0,i.kt)("p",null,"For the purposes of signing Cosmos messages, the ",(0,i.kt)("inlineCode",{parentName:"p"},"@chain_id")," field must correspond\nto the Cosmos chain identifier. The user-agent should ",(0,i.kt)("strong",{parentName:"p"},"refuse")," signing if the\n",(0,i.kt)("inlineCode",{parentName:"p"},"@chain_id")," field does not match the currently active chain! The ",(0,i.kt)("inlineCode",{parentName:"p"},"@type")," field\nmust equal the constant ",(0,i.kt)("inlineCode",{parentName:"p"},'"message"'),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"@type")," field corresponds to the type of\nstructure the user will be signing in an application. For now, a user is only\nallowed to sign bytes of valid ASCII text (",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cometbft/cometbft/blob/v0.37.0/libs/strings/string.go#L35-L64"},"see here"),").\nHowever, this will change and evolve to support additional application-specific\nstructures that are human-readable and machine-verifiable (",(0,i.kt)("a",{parentName:"p",href:"#future-adaptations"},"see Future Adaptations"),")."),(0,i.kt)("p",null,"Thus, we can have a canonical JSON structure for signing Cosmos messages using\nthe ",(0,i.kt)("a",{parentName:"p",href:"http://json-schema.org/"},"JSON schema")," specification as such:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "$schema": "http://json-schema.org/draft-04/schema#",\n  "$id": "cosmos/signing/typeData/schema",\n  "title": "The Cosmos signed message typed data schema.",\n  "type": "object",\n  "properties": {\n    "@chain_id": {\n      "type": "string",\n      "description": "The corresponding Cosmos chain identifier.",\n      "minLength": 1\n    },\n    "@type": {\n      "type": "string",\n      "description": "The message type. It must be \'message\'.",\n      "enum": [\n        "message"\n      ]\n    },\n    "text": {\n      "type": "string",\n      "description": "The valid ASCII text to sign.",\n      "pattern": "^[\\\\x20-\\\\x7E]+$",\n      "minLength": 1\n    }\n  },\n  "required": [\n    "@chain_id",\n    "@type",\n    "text"\n  ]\n}\n')),(0,i.kt)("p",null,"e.g."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "@chain_id": "1",\n  "@type": "message",\n  "text": "Hello, you can identify me as XYZ on keybase."\n}\n')),(0,i.kt)("h2",{id:"future-adaptations"},"Future Adaptations"),(0,i.kt)("p",null,"As applications can vary greatly in domain, it will be vital to support both\ndomain separation and human-readable and machine-verifiable structures."),(0,i.kt)("p",null,"Domain separation will allow for application developers to prevent collisions of\notherwise identical structures. It should be designed to be unique per application\nuse and should directly be used in the signature encoding itself."),(0,i.kt)("p",null,"Human-readable and machine-verifiable structures will allow end users to sign\nmore complex structures, apart from just string messages, and still be able to\nknow exactly what they are signing (opposed to signing a bunch of arbitrary bytes)."),(0,i.kt)("p",null,"Thus, in the future, the Cosmos signing message specification will be expected\nto expand upon it's canonical JSON structure to include such functionality."),(0,i.kt)("h2",{id:"api"},"API"),(0,i.kt)("p",null,"Application developers and designers should formalize a standard set of APIs that\nadhere to the following specification:"),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"cosmossignbytes"},(0,i.kt)("strong",{parentName:"h3"},"cosmosSignBytes")),(0,i.kt)("p",null,"Params:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"data"),": the Cosmos signed message canonical JSON structure"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"address"),": the Bech32 Cosmos account address to sign data with")),(0,i.kt)("p",null,"Returns:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"signature"),": the Cosmos signature derived using signing algorithm ",(0,i.kt)("inlineCode",{parentName:"li"},"S"))),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"examples"},"Examples"),(0,i.kt)("p",null,"Using the ",(0,i.kt)("inlineCode",{parentName:"p"},"secp256k1")," as the DSA, ",(0,i.kt)("inlineCode",{parentName:"p"},"S"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'data = {\n  "@chain_id": "1",\n  "@type": "message",\n  "text": "I hereby claim I am ABC on Keybase!"\n}\n\ncosmosSignBytes(data, "cosmos1pvsch6cddahhrn5e8ekw0us50dpnugwnlfngt3")\n> "0x7fc4a495473045022100dec81a9820df0102381cdbf7e8b0f1e2cb64c58e0ecda1324543742e0388e41a02200df37905a6505c1b56a404e23b7473d2c0bc5bcda96771d2dda59df6ed2b98f8"\n')),(0,i.kt)("h2",{id:"references"},"References"))}u.isMDXComponent=!0}}]);