"use strict";(self.webpackChunkcosmos_sdk_docs=self.webpackChunkcosmos_sdk_docs||[]).push([[92061],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var o=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=o.createContext({}),p=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return o.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(n),m=i,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||a;return n?o.createElement(h,r(r({ref:t},c),{},{components:n})):o.createElement(h,r({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,r=new Array(a);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<a;p++)r[p]=n[p];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},34087:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>p});var o=n(87462),i=(n(67294),n(3905));const a={},r="Introduction",l={unversionedId:"build/abci/introduction",id:"build/abci/introduction",title:"Introduction",description:"What is ABCI?",source:"@site/docs/build/abci/00-introduction.md",sourceDirName:"build/abci",slug:"/build/abci/introduction",permalink:"/main/build/abci/introduction",draft:!1,tags:[],version:"current",sidebarPosition:0,frontMatter:{},sidebar:"buildSidebar",previous:{title:"PreBlocker",permalink:"/main/build/building-modules/preblock"},next:{title:"Prepare Proposal",permalink:"/main/build/abci/prepare-proposal"}},s={},p=[{value:"What is ABCI?",id:"what-is-abci",level:2},{value:"The Flow",id:"the-flow",level:2},{value:"PrepareProposal",id:"prepareproposal",level:2},{value:"ProcessProposal",id:"processproposal",level:2},{value:"ExtendVote and VerifyVoteExtensions",id:"extendvote-and-verifyvoteextensions",level:2},{value:"FinalizeBlock",id:"finalizeblock",level:2}],c={toc:p},d="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"introduction"},"Introduction"),(0,i.kt)("h2",{id:"what-is-abci"},"What is ABCI?"),(0,i.kt)("p",null,"ABCI, Application Blockchain Interface is the interface between CometBFT and the application. More information about ABCI can be found ",(0,i.kt)("a",{parentName:"p",href:"https://docs.cometbft.com/v0.38/spec/abci/"},"here"),". CometBFT version 0.38 included a new version of ABCI (called ABCI 2.0) which added several new methods."),(0,i.kt)("p",null,"The 5 methods introduced in ABCI 2.0 are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PrepareProposal")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ProcessProposal")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ExtendVote")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"VerifyVoteExtension")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"FinalizeBlock"))),(0,i.kt)("h2",{id:"the-flow"},"The Flow"),(0,i.kt)("h2",{id:"prepareproposal"},"PrepareProposal"),(0,i.kt)("p",null,"Based on validator voting power, CometBFT chooses a block proposer and calls ",(0,i.kt)("inlineCode",{parentName:"p"},"PrepareProposal")," on the block proposer's application (Cosmos SDK). The selected block proposer is responsible for collecting outstanding transactions from the mempool, adhering to the application's specifications. The application can enforce custom transaction ordering and incorporate additional transactions, potentially generated from vote extensions in the previous block."),(0,i.kt)("p",null,"To perform this manipulation on the application side, a custom handler must be implemented. By default, the Cosmos SDK provides ",(0,i.kt)("inlineCode",{parentName:"p"},"PrepareProposalHandler"),", used in conjunction with an application specific mempool. A custom handler can be written by an application developer, if a noop handler is provided, all transactions are considered valid."),(0,i.kt)("p",null,"Please note that vote extensions will only be available on the following height in which vote extensions are enabled. More information about vote extensions can be found ",(0,i.kt)("a",{parentName:"p",href:"https://docs.cosmos.network/main/build/abci/vote-extensions"},"here"),"."),(0,i.kt)("p",null,"After creating the proposal, the proposer returns it to CometBFT."),(0,i.kt)("p",null,"PrepareProposal CAN be non-deterministic."),(0,i.kt)("h2",{id:"processproposal"},"ProcessProposal"),(0,i.kt)("p",null,"This method allows validators to perform application-specific checks on the block proposal and is called on all validators. This is an important step in the consensus process, as it ensures that the block is valid and meets the requirements of the application. For example, validators could check that the block contains all the required transactions or that the block does not create any invalid state transitions."),(0,i.kt)("p",null,"The implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"ProcessProposal")," MUST be deterministic."),(0,i.kt)("h2",{id:"extendvote-and-verifyvoteextensions"},"ExtendVote and VerifyVoteExtensions"),(0,i.kt)("p",null,"These methods allow applications to extend the voting process by requiring validators to perform additional actions beyond simply validating blocks."),(0,i.kt)("p",null,"If vote extensions are enabled, ",(0,i.kt)("inlineCode",{parentName:"p"},"ExtendVote")," will be called on every validator and each one will return its vote extension which is in practice a bunch of bytes. As mentioned above this data (vote extension) can only be retrieved in the next block height during ",(0,i.kt)("inlineCode",{parentName:"p"},"PrepareProposal"),". Additionally, this data can be arbitrary, but in the provided tutorials, it serves as an oracle or proof of transactions in the mempool. Essentially, vote extensions are processed and injected as transactions. Examples of use-cases for vote extensions include prices for a price oracle or encryption shares for an encrypted transaction mempool. ",(0,i.kt)("inlineCode",{parentName:"p"},"ExtendVote")," CAN be non-deterministic."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"VerifyVoteExtensions")," is performed on every validator multiple times in order to verify other validators' vote extensions. This check is performed to validate the integrity and validity of the vote extensions preventing malicious or invalid vote extensions."),(0,i.kt)("p",null,"Additionally, applications must keep the vote extension data concise as it can degrade the performance of their chain, see testing results ",(0,i.kt)("a",{parentName:"p",href:"https://docs.cometbft.com/v0.38/qa/cometbft-qa-38#vote-extensions-testbed"},"here"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"VerifyVoteExtensions")," MUST be deterministic."),(0,i.kt)("h2",{id:"finalizeblock"},"FinalizeBlock"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"FinalizeBlock")," is then called and is responsible for updating the state of the blockchain and making the block available to users."))}u.isMDXComponent=!0}}]);