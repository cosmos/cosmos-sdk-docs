"use strict";(self.webpackChunkcosmos_sdk_docs=self.webpackChunkcosmos_sdk_docs||[]).push([[11868],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>h});var r=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var d=r.createContext({}),l=function(e){var n=r.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=l(e.components);return r.createElement(d.Provider,{value:n},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,d=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=l(t),p=o,h=u["".concat(d,".").concat(p)]||u[p]||m[p]||a;return t?r.createElement(h,i(i({ref:n},c),{},{components:t})):r.createElement(h,i({ref:n},c))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=p;var s={};for(var d in n)hasOwnProperty.call(n,d)&&(s[d]=n[d]);s.originalType=e,s[u]="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=t[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},42401:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var r=t(87462),o=(t(67294),t(3905));const a={},i="ADR 070: Unordered Transactions",s={unversionedId:"build/architecture/adr-070-unordered-account",id:"version-0.5/build/architecture/adr-070-unordered-account",title:"ADR 070: Unordered Transactions",description:"Changelog",source:"@site/versioned_docs/version-0.5/build/architecture/adr-070-unordered-account.md",sourceDirName:"build/architecture",slug:"/build/architecture/adr-070-unordered-account",permalink:"/v0.50/build/architecture/adr-070-unordered-account",draft:!1,tags:[],version:"0.5",frontMatter:{},sidebar:"buildSidebar",previous:{title:"ADR 068: Preblock",permalink:"/v0.50/build/architecture/adr-068-preblock"},next:{title:"Cosmos SDK Transaction Malleability Risk Review and Recommendations",permalink:"/v0.50/build/architecture/adr-076-tx-malleability"}},d={},l=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Abstract",id:"abstract",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Transaction Format",id:"transaction-format",level:3},{value:"Replay Protection",id:"replay-protection",level:3},{value:"AnteHandler Decorator",id:"antehandler-decorator",level:3},{value:"Unordered Sequences",id:"unordered-sequences",level:3},{value:"State Management",id:"state-management",level:3},{value:"Note On Previous Design Iteration",id:"note-on-previous-design-iteration",level:2},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"References",id:"references",level:2}],c={toc:l},u="wrapper";function m(e){let{components:n,...t}=e;return(0,o.kt)(u,(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"adr-070-unordered-transactions"},"ADR 070: Unordered Transactions"),(0,o.kt)("h2",{id:"changelog"},"Changelog"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Dec 4, 2023: Initial Draft (@yihuang, @tac0turtle, @alexanderbez)"),(0,o.kt)("li",{parentName:"ul"},"Jan 30, 2024: Include section on deterministic transaction encoding"),(0,o.kt)("li",{parentName:"ul"},"Mar 18, 2025: Revise implementation to use Cosmos SDK KV Store and require unique timeouts per-address (@technicallyty)"),(0,o.kt)("li",{parentName:"ul"},"Apr 25, 2025: Add note about rejecting unordered txs with sequence values.")),(0,o.kt)("h2",{id:"status"},"Status"),(0,o.kt)("p",null,"ACCEPTED Not Implemented"),(0,o.kt)("h2",{id:"abstract"},"Abstract"),(0,o.kt)("p",null,"We propose a way to do replay-attack protection without enforcing the order of\ntransactions and without requiring the use of monotonically increasing sequences. Instead, we propose\nthe use of a time-based, ephemeral sequence."),(0,o.kt)("h2",{id:"context"},"Context"),(0,o.kt)("p",null,"Account sequence values serve to prevent replay attacks and ensure transactions from the same sender are included into blocks and executed\nin sequential order. Unfortunately, this makes it difficult to reliably send many concurrent transactions from the\nsame sender. Victims of such limitations include IBC relayers and crypto exchanges."),(0,o.kt)("h2",{id:"decision"},"Decision"),(0,o.kt)("p",null,"We propose adding a boolean field ",(0,o.kt)("inlineCode",{parentName:"p"},"unordered")," and a google.protobuf.Timestamp field ",(0,o.kt)("inlineCode",{parentName:"p"},"timeout_timestamp")," to the transaction body."),(0,o.kt)("p",null,"Unordered transactions will bypass the traditional account sequence rules and follow the rules described\nbelow, without impacting traditional ordered transactions which will follow the same sequence rules as before."),(0,o.kt)("p",null,"We will introduce new storage of time-based, ephemeral unordered sequences using the SDK's existing KV Store library.\nSpecifically, we will leverage the existing x/auth KV store to store the unordered sequences."),(0,o.kt)("p",null,"When an unordered transaction is included in a block, a concatenation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"timeout_timestamp")," and sender\u2019s address bytes\nwill be recorded to state (i.e. ",(0,o.kt)("inlineCode",{parentName:"p"},"542939323/<address_bytes>"),"). In cases of multi-party signing, one entry per signer\nwill be recorded to state."),(0,o.kt)("p",null,"New transactions will be checked against the state to prevent duplicate submissions. To prevent the state from growing indefinitely, we propose the following:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Define an upper bound for the value of ",(0,o.kt)("inlineCode",{parentName:"li"},"timeout_timestamp")," (i.e. 10 minutes)."),(0,o.kt)("li",{parentName:"ul"},"Add PreBlocker method x/auth that removes state entries with a ",(0,o.kt)("inlineCode",{parentName:"li"},"timeout_timestamp")," earlier than the current block time.")),(0,o.kt)("h3",{id:"transaction-format"},"Transaction Format"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-protobuf"},"message TxBody {\n  ...\n          \n  bool unordered = 4;\n  google.protobuf.Timestamp timeout_timestamp = 5\n}\n")),(0,o.kt)("h3",{id:"replay-protection"},"Replay Protection"),(0,o.kt)("p",null,"We facilitate replay protection by storing the unordered sequence in the Cosmos SDK KV store. Upon transaction ingress, we check if the transaction's unordered\nsequence exists in state, or if the TTL value is stale, i.e. before the current block time. If so, we reject it. Otherwise,\nwe add the unordered sequence to the state. This section of the state will belong to the ",(0,o.kt)("inlineCode",{parentName:"p"},"x/auth")," module."),(0,o.kt)("p",null,"The state is evaluated during x/auth's ",(0,o.kt)("inlineCode",{parentName:"p"},"PreBlocker"),". All transactions with an unordered sequence earlier than the current block time\nwill be deleted."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"func (am AppModule) PreBlock(ctx context.Context) (appmodule.ResponsePreBlock, error) {\n    err := am.accountKeeper.RemoveExpired(sdk.UnwrapSDKContext(ctx))\n    if err != nil {\n        return nil, err\n    }\n    return &sdk.ResponsePreBlock{ConsensusParamsChanged: false}, nil\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-golang"},'package keeper\n\nimport (\n    sdk "github.com/cosmos/cosmos-sdk/types"\n\n    "cosmossdk.io/collections"\n    "cosmossdk.io/core/store"\n)\n\nvar (\n    // just arbitrarily picking some upper bound number.\n    unorderedSequencePrefix = collections.NewPrefix(90)\n)\n\ntype AccountKeeper struct {\n    // ...\n    unorderedSequences collections.KeySet[collections.Pair[uint64, []byte]]\n}\n\nfunc (m *AccountKeeper) Contains(ctx sdk.Context, sender []byte, timestamp uint64) (bool, error) {\n    return m.unorderedSequences.Has(ctx, collections.Join(timestamp, sender))\n}\n\nfunc (m *AccountKeeper) Add(ctx sdk.Context, sender []byte, timestamp uint64) error {\n    return m.unorderedSequences.Set(ctx, collections.Join(timestamp, sender))\n}\n\nfunc (m *AccountKeeper) RemoveExpired(ctx sdk.Context) error {\n    blkTime := ctx.BlockTime().UnixNano()\n    it, err := m.unorderedSequences.Iterate(ctx, collections.NewPrefixUntilPairRange[uint64, []byte](uint64(blkTime)))\n    if err != nil {\n        return err\n    }\n    defer it.Close()\n\n    keys, err := it.Keys()\n    if err != nil {\n        return err\n    }\n\n    for _, key := range keys {\n        if err := m.unorderedSequences.Remove(ctx, key); err != nil {\n            return err\n        }\n    }\n\n    return nil\n}\n\n')),(0,o.kt)("h3",{id:"antehandler-decorator"},"AnteHandler Decorator"),(0,o.kt)("p",null,"To facilitate bypassing nonce verification, we must modify the existing\n",(0,o.kt)("inlineCode",{parentName:"p"},"IncrementSequenceDecorator")," AnteHandler decorator to skip the nonce verification\nwhen the transaction is marked as unordered."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-golang"},"func (isd IncrementSequenceDecorator) AnteHandle(ctx sdk.Context, tx sdk.Tx, simulate bool, next sdk.AnteHandler) (sdk.Context, error) {\n  if tx.UnOrdered() {\n    return next(ctx, tx, simulate)\n  }\n\n  // ...\n}\n")),(0,o.kt)("p",null,"We also introduce a new decorator to perform the unordered transaction verification."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-golang"},'package ante\n\nimport (\n    "slices"\n    "strings"\n    "time"\n\n    sdk "github.com/cosmos/cosmos-sdk/types"\n    sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"\n    authkeeper "github.com/cosmos/cosmos-sdk/x/auth/keeper"\n    authsigning "github.com/cosmos/cosmos-sdk/x/auth/signing"\n\n    errorsmod "cosmossdk.io/errors"\n)\n\nvar _ sdk.AnteDecorator = (*UnorderedTxDecorator)(nil)\n\n// UnorderedTxDecorator defines an AnteHandler decorator that is responsible for\n// checking if a transaction is intended to be unordered and, if so, evaluates\n// the transaction accordingly. An unordered transaction will bypass having its\n// nonce incremented, which allows fire-and-forget transaction broadcasting,\n// removing the necessity of ordering on the sender-side.\n//\n// The transaction sender must ensure that unordered=true and a timeout_height\n// is appropriately set. The AnteHandler will check that the transaction is not\n// a duplicate and will evict it from state when the timeout is reached.\n//\n// The UnorderedTxDecorator should be placed as early as possible in the AnteHandler\n// chain to ensure that during DeliverTx, the transaction is added to the unordered sequence state.\ntype UnorderedTxDecorator struct {\n    // maxUnOrderedTTL defines the maximum TTL a transaction can define.\n    maxTimeoutDuration time.Duration\n    txManager          authkeeper.UnorderedTxManager\n}\n\nfunc NewUnorderedTxDecorator(\n    utxm authkeeper.UnorderedTxManager,\n) *UnorderedTxDecorator {\n    return &UnorderedTxDecorator{\n        maxTimeoutDuration: 10 * time.Minute,\n        txManager:          utxm,\n    }\n}\n\nfunc (d *UnorderedTxDecorator) AnteHandle(\n    ctx sdk.Context,\n    tx sdk.Tx,\n    _ bool,\n    next sdk.AnteHandler,\n) (sdk.Context, error) {\n    if err := d.ValidateTx(ctx, tx); err != nil {\n        return ctx, err\n    }\n    return next(ctx, tx, false)\n}\n\nfunc (d *UnorderedTxDecorator) ValidateTx(ctx sdk.Context, tx sdk.Tx) error {\n    unorderedTx, ok := tx.(sdk.TxWithUnordered)\n    if !ok || !unorderedTx.GetUnordered() {\n        // If the transaction does not implement unordered capabilities or has the\n        // unordered value as false, we bypass.\n        return nil\n    }\n\n    blockTime := ctx.BlockTime()\n    timeoutTimestamp := unorderedTx.GetTimeoutTimeStamp()\n    if timeoutTimestamp.IsZero() || timeoutTimestamp.Unix() == 0 {\n        return errorsmod.Wrap(\n            sdkerrors.ErrInvalidRequest,\n            "unordered transaction must have timeout_timestamp set",\n        )\n    }\n    if timeoutTimestamp.Before(blockTime) {\n        return errorsmod.Wrap(\n            sdkerrors.ErrInvalidRequest,\n            "unordered transaction has a timeout_timestamp that has already passed",\n        )\n    }\n    if timeoutTimestamp.After(blockTime.Add(d.maxTimeoutDuration)) {\n        return errorsmod.Wrapf(\n            sdkerrors.ErrInvalidRequest,\n            "unordered tx ttl exceeds %s",\n            d.maxTimeoutDuration.String(),\n        )\n    }\n\n    execMode := ctx.ExecMode()\n    if execMode == sdk.ExecModeSimulate {\n        return nil\n    }\n\n    signerAddrs, err := getSigners(tx)\n    if err != nil {\n        return err\n    }\n    \n    for _, signer := range signerAddrs {\n        contains, err := d.txManager.Contains(ctx, signer, uint64(unorderedTx.GetTimeoutTimeStamp().Unix()))\n        if err != nil {\n            return errorsmod.Wrap(\n                sdkerrors.ErrIO,\n                "failed to check contains",\n            )\n        }\n        if contains {\n            return errorsmod.Wrapf(\n                sdkerrors.ErrInvalidRequest,\n                "tx is duplicated for signer %x", signer,\n            )\n        }\n\n        if err := d.txManager.Add(ctx, signer, uint64(unorderedTx.GetTimeoutTimeStamp().Unix())); err != nil {\n            return errorsmod.Wrap(\n                sdkerrors.ErrIO,\n                "failed to add unordered sequence to state",\n            )\n        }\n    }\n    \n    \n    return nil\n}\n\nfunc getSigners(tx sdk.Tx) ([][]byte, error) {\n    sigTx, ok := tx.(authsigning.SigVerifiableTx)\n    if !ok {\n        return nil, errorsmod.Wrap(sdkerrors.ErrTxDecode, "invalid tx type")\n    }\n    return sigTx.GetSigners()\n}\n\n')),(0,o.kt)("h3",{id:"unordered-sequences"},"Unordered Sequences"),(0,o.kt)("p",null,"Unordered sequences provide a simple, straightforward mechanism to protect against both transaction malleability and\ntransaction duplication. It is important to note that the unordered sequence must still be unique. However,\nthe value is not required to be strictly increasing as with regular sequences, and the order in which the node receives\nthe transactions no longer matters. Clients can handle building unordered transactions similarly to the code below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"for _, tx := range txs {\n    tx.SetUnordered(true)\n    tx.SetTimeoutTimestamp(time.Now() + 1 * time.Nanosecond)\n}\n")),(0,o.kt)("p",null,"We will reject transactions that have both sequence and unordered timeouts set. We do this to avoid assuming the intent of the user."),(0,o.kt)("h3",{id:"state-management"},"State Management"),(0,o.kt)("p",null,"The storage of unordered sequences will be facilitated using the Cosmos SDK's KV Store service."),(0,o.kt)("h2",{id:"note-on-previous-design-iteration"},"Note On Previous Design Iteration"),(0,o.kt)("p",null,"The previous iteration of unordered transactions worked by using an ad-hoc state-management system that posed severe\nrisks and a vector for duplicated tx processing. It relied on graceful app closure which would flush the current state\nof the unordered sequence mapping. If the 2/3's of the network crashed, and the graceful closure did not trigger,\nthe system would lose track of all sequences in the mapping, allowing those transactions to be replayed. The\nimplementation proposed in the updated version of this ADR solves this by writing directly to the Cosmos KV Store.\nWhile this is less performant, for the initial implementation, we opted to choose a safer path and postpone performance optimizations until we have more data on real-world impacts and a more battle-tested approach to optimization."),(0,o.kt)("p",null,'Additionally, the previous iteration relied on using hashes to create what we call an "unordered sequence." There are known\nissues with transaction malleability in Cosmos SDK signing modes. This ADR gets away from this problem by enforcing\nsingle-use unordered nonces, instead of deriving nonces from bytes in the transaction.'),(0,o.kt)("h2",{id:"consequences"},"Consequences"),(0,o.kt)("h3",{id:"positive"},"Positive"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},'Support unordered transaction inclusion, enabling the ability to "fire and forget" many transactions at once.')),(0,o.kt)("h3",{id:"negative"},"Negative"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Requires additional storage overhead."),(0,o.kt)("li",{parentName:"ul"},"Requirement of unique timestamps per transaction causes a small amount of additional overhead for clients. Clients must ensure each transaction's timeout timestamp is different. However, nanosecond differentials suffice."),(0,o.kt)("li",{parentName:"ul"},"Usage of Cosmos SDK KV store is slower in comparison to using a non-merklized store or ad-hoc methods, and block times may slow down as a result.")),(0,o.kt)("h2",{id:"references"},"References"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/cosmos/cosmos-sdk/issues/13009"},"https://github.com/cosmos/cosmos-sdk/issues/13009"))))}m.isMDXComponent=!0}}]);