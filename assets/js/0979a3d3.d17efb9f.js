"use strict";(self.webpackChunkcosmos_sdk_docs=self.webpackChunkcosmos_sdk_docs||[]).push([[13320],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),d=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=d(e.components);return i.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=d(n),p=a,h=u["".concat(l,".").concat(p)]||u[p]||m[p]||o;return n?i.createElement(h,r(r({ref:t},c),{},{components:n})):i.createElement(h,r({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:a,r[1]=s;for(var d=2;d<o;d++)r[d]=n[d];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}p.displayName="MDXCreateElement"},76739:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var i=n(87462),a=(n(67294),n(3905));const o={},r="Cosmos SDK Transaction Malleability Risk Review and Recommendations",s={unversionedId:"build/architecture/adr-076-tx-malleability",id:"build/architecture/adr-076-tx-malleability",title:"Cosmos SDK Transaction Malleability Risk Review and Recommendations",description:"Changelog",source:"@site/docs/build/architecture/adr-076-tx-malleability.md",sourceDirName:"build/architecture",slug:"/build/architecture/adr-076-tx-malleability",permalink:"/main/build/architecture/adr-076-tx-malleability",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"buildSidebar",previous:{title:"ADR 070: Unordered Transactions",permalink:"/main/build/architecture/adr-070-unordered-account"},next:{title:"ADR {ADR-NUMBER}:",permalink:"/main/build/architecture/adr-template"}},l={},d=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Abstract",id:"abstract",level:2},{value:"Review",id:"review",level:2},{value:"Risks Associated with Malleability",id:"risks-associated-with-malleability",level:3},{value:"Sources of Malleability",id:"sources-of-malleability",level:3},{value:"Non-deterministic Protobuf Encoding",id:"non-deterministic-protobuf-encoding",level:4},{value:"Non-deterministic Value Encoding",id:"non-deterministic-value-encoding",level:4},{value:"Signature Encoding",id:"signature-encoding",level:4},{value:"Fields not covered by Amino JSON",id:"fields-not-covered-by-amino-json",level:4},{value:"Sign Mode Summary and Recommendations",id:"sign-mode-summary-and-recommendations",level:2},{value:"Testing",id:"testing",level:2},{value:"References",id:"references",level:2}],c={toc:d},u="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"cosmos-sdk-transaction-malleability-risk-review-and-recommendations"},"Cosmos SDK Transaction Malleability Risk Review and Recommendations"),(0,a.kt)("h2",{id:"changelog"},"Changelog"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"2025-03-10: Initial draft (@aaronc)")),(0,a.kt)("h2",{id:"status"},"Status"),(0,a.kt)("p",null,"PROPOSED: Not Implemented"),(0,a.kt)("h2",{id:"abstract"},"Abstract"),(0,a.kt)("p",null,"Several encoding and sign mode related issues have historically resulted in the possibility\nthat Cosmos SDK transactions may be re-encoded in such a way as to change their hash\n(and in rare cases, their meaning) without invalidating the signature.\nThis document details these cases, their potential risks, the extent to which they have been\naddressed, and provides recommendations for future improvements."),(0,a.kt)("h2",{id:"review"},"Review"),(0,a.kt)("p",null,"One naive assumption about Cosmos SDK transactions is that hashing the raw bytes of a submitted transaction creates a safe unique identifier for the transaction. In reality, there are multiple ways in which transactions could be manipulated to create different transaction bytes (and as a result different hashes) that still pass signature verification."),(0,a.kt)("p",null,'This document attempts to enumerate the various potential transaction "malleability" risks that we have identified and the extent to which they have or have not been addressed in various sign modes. We also identify vulnerabilities that could be introduced if developers make changes in the future without careful consideration of the complexities involved with transaction encoding, sign modes and signatures.'),(0,a.kt)("h3",{id:"risks-associated-with-malleability"},"Risks Associated with Malleability"),(0,a.kt)("p",null,"The malleability of transactions poses the following potential risks to end users:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"unsigned data could get added to transactions and be processed by state machines"),(0,a.kt)("li",{parentName:"ul"},"clients often rely on transaction hashes for checking transaction status, but whether or not submitted transaction hashes match processed transaction hashes depends primarily on good network actors rather than fundamental protocol guarantees"),(0,a.kt)("li",{parentName:"ul"},"transactions could potentially get executed more than once (faulty replay protection)")),(0,a.kt)("p",null,"If a client generates a transaction, keeps a record of its hash and then attempts to query nodes to check the transaction's status, this process may falsely conclude that the transaction had not been processed if an intermediary\nprocessor decoded and re-encoded the transaction with different encoding rules (either maliciously or unintentionally).\nAs long as no malleability is present in the signature bytes themselves, clients ",(0,a.kt)("em",{parentName:"p"},"should")," query transactions by signature instead of hash."),(0,a.kt)("p",null,"Not being cognizant of this risk may lead clients to submit the same transaction multiple times if they believe that\nearlier transactions had failed or gotten lost in processing.\nThis could be an attack vector against users if wallets primarily query transactions by hash."),(0,a.kt)("p",null,"If the state machine were to rely on transaction hashes as a replay mechanism itself, this would be faulty and not\nprovide the intended replay protection. Instead, the state machine should rely on deterministic representations of\ntransactions rather than the raw encoding, or other nonces,\nif they want to provide some replay protection that doesn't rely on a monotonically\nincreasing account sequence number."),(0,a.kt)("h3",{id:"sources-of-malleability"},"Sources of Malleability"),(0,a.kt)("h4",{id:"non-deterministic-protobuf-encoding"},"Non-deterministic Protobuf Encoding"),(0,a.kt)("p",null,"Cosmos SDK transactions are encoded using protobuf binary encoding when they are submitted to the network. Protobuf binary is not inherently a deterministic encoding meaning that the same logical payload could have several valid bytes representations. In a basic sense, this means that protobuf in general can be decoded and re-encoded to produce a different byte stream (and thus different hash) without changing the logical meaning of the bytes. ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/blob/main/docs/architecture/adr-027-deterministic-protobuf-serialization.md"},"ADR 027: Deterministic Protobuf Serialization"),' describes in detail what needs to be done to produce what we consider to be a "canonical", deterministic protobuf serialization. Briefly, the following sources of malleability at the encoding level have been identified and are addressed by this specification:'),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"fields can be emitted in any order"),(0,a.kt)("li",{parentName:"ul"},"default field values can be included or omitted, and this doesn't change meaning unless ",(0,a.kt)("inlineCode",{parentName:"li"},"optional")," is used"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"repeated"),' fields of scalars may use packed or "regular" encoding'),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"varint"),"s can include extra ignored bits"),(0,a.kt)("li",{parentName:"ul"},"extra fields may be added and are usually simply ignored by decoders. ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/cosmos/cosmos-sdk/blob/main/docs/architecture/adr-020-protobuf-transaction-encoding.md#unknown-field-filtering"},"ADR 020")," specifies that in general such extra fields should cause messages and transactions to be rejected")),(0,a.kt)("p",null,"When using ",(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_DIRECT")," none of the above malleabilities will be tolerated because:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"signatures of messages and extensions must be done over the raw encoded bytes of those fields"),(0,a.kt)("li",{parentName:"ul"},"the outer tx envelope (",(0,a.kt)("inlineCode",{parentName:"li"},"TxRaw"),") must follow ADR 027 rules or be rejected")),(0,a.kt)("p",null,"Transactions signed with ",(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_LEGACY_AMINO_JSON"),", however, have no way of protecting against the above malleabilities because what is signed is a JSON representation of the logical contents of the transaction. These logical contents could have any number of valid protobuf binary encodings, so in general there are no guarantees regarding transaction hash with Amino JSON signing."),(0,a.kt)("p",null,"In addition to being aware of the general non-determinism of protobuf binary, developers need to pay special attention to make sure that unknown protobuf fields get rejected when developing new capabilities related to protobuf transactions. The protobuf serialization format was designed with the assumption that unknown data known to encoders could safely be ignored by decoders. This assumption may have been fairly safe within the walled garden of Google's centralized infrastructure. However, in distributed blockchain systems, this assumption is generally unsafe. If a newer client encodes a protobuf message with data intended for a newer server, it is not safe for an older server to simply ignore and discard instructions that it does not understand. These instructions could include critical information that the transaction signer is relying upon and just assuming that it is unimportant is not safe."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/blob/main/docs/architecture/adr-020-protobuf-transaction-encoding.md#unknown-field-filtering"},"ADR 020"),' specifies some provisions for "non-critical" fields which can safely be ignored by older servers. In practice, I have not seen any valid usages of this. It is something in the design that maintainers should be aware of, but it may not be necessary or even 100% safe.'),(0,a.kt)("h4",{id:"non-deterministic-value-encoding"},"Non-deterministic Value Encoding"),(0,a.kt)("p",null,"In addition to the non-determinism present in protobuf binary itself, some protobuf field data is encoded using a micro-format which itself may not be deterministic. Consider for instance integer or decimal encoding. Some decoders may allow for the presence of leading or trailing zeros without changing the logical meaning, ex. ",(0,a.kt)("inlineCode",{parentName:"p"},"00100")," vs ",(0,a.kt)("inlineCode",{parentName:"p"},"100")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"100.00")," vs ",(0,a.kt)("inlineCode",{parentName:"p"},"100"),". So if a sign mode encodes numbers deterministically, but decoders accept multiple representations,\na user may sign over the value ",(0,a.kt)("inlineCode",{parentName:"p"},"100")," while ",(0,a.kt)("inlineCode",{parentName:"p"},"0100")," gets encoded. This would be possible with Amino JSON to the extent that the integer decoder accepts leading zeros. I believe the current ",(0,a.kt)("inlineCode",{parentName:"p"},"Int")," implementation will reject this, however, it is\nprobably possible to encode an octal or hexadecimal representation in the transaction whereas the user signs over a decimal integer."),(0,a.kt)("h4",{id:"signature-encoding"},"Signature Encoding"),(0,a.kt)("p",null,"Signatures themselves are encoded using a micro-format specific to the signature algorithm being used and sometimes these\nmicro-formats can allow for non-determinism (multiple valid bytes for the same signature).\nMost of the signature algorithms supported by the SDK should reject non-canonical bytes in their current implementation.\nHowever, the ",(0,a.kt)("inlineCode",{parentName:"p"},"Multisignature")," protobuf type uses normal protobuf encoding and there is no check as to whether the\ndecoded bytes followed canonical ADR 027 rules or not. Therefore, multisig transactions can have malleability in\ntheir signatures.\nAny new or custom signature algorithms must make sure that they reject any non-canonical bytes, otherwise even\nwith ",(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_DIRECT")," there can be transaction hash malleability by re-encoding signatures with a non-canonical\nrepresentation."),(0,a.kt)("h4",{id:"fields-not-covered-by-amino-json"},"Fields not covered by Amino JSON"),(0,a.kt)("p",null,"Another area that needs to be addressed carefully is the discrepancy between ",(0,a.kt)("inlineCode",{parentName:"p"},"AminoSignDoc")," (see ",(0,a.kt)("a",{parentName:"p",href:"../../x/tx/signing/aminojson/internal/aminojsonpb/aminojson.proto"},(0,a.kt)("inlineCode",{parentName:"a"},"aminojson.proto")),") used for ",(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_LEGACY_AMINO_JSON")," and the actual contents of ",(0,a.kt)("inlineCode",{parentName:"p"},"TxBody")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"AuthInfo")," (see ",(0,a.kt)("a",{parentName:"p",href:"../../proto/cosmos/tx/v1beta1/tx.proto"},(0,a.kt)("inlineCode",{parentName:"a"},"tx.proto")),").\nIf fields get added to ",(0,a.kt)("inlineCode",{parentName:"p"},"TxBody")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"AuthInfo"),", they must either have a corresponding representation in ",(0,a.kt)("inlineCode",{parentName:"p"},"AminoSignDoc")," or Amino JSON signatures must be rejected when those new fields are set. Making sure that this is done is a\nhighly manual process, and developers could easily make the mistake of updating ",(0,a.kt)("inlineCode",{parentName:"p"},"TxBody")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"AuthInfo"),"\nwithout paying any attention to the implementation of ",(0,a.kt)("inlineCode",{parentName:"p"},"GetSignBytes")," for Amino JSON. This is a critical\nvulnerability in which unsigned content can now get into the transaction and signature verification will\npass."),(0,a.kt)("h2",{id:"sign-mode-summary-and-recommendations"},"Sign Mode Summary and Recommendations"),(0,a.kt)("p",null,"The sign modes officially supported by the SDK are ",(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_DIRECT"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_TEXTUAL"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_DIRECT_AUX"),",\nand ",(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_LEGACY_AMINO_JSON"),".\n",(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_LEGACY_AMINO_JSON")," is used commonly by wallets and is currently the only sign mode supported on Nano Ledger hardware devices\n(although ",(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_TEXTUAL")," was designed to also support hardware devices).\n",(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_DIRECT")," is the simplest sign mode and its usage is also fairly common.\n",(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_DIRECT_AUX")," is a variant of ",(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_DIRECT")," that can be used by auxiliary signers in a multi-signer\ntransaction by those signers who are not paying gas.\n",(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_TEXTUAL")," was intended as a replacement for ",(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_LEGACY_AMINO_JSON"),", but as far as we know it\nhas not been adopted by any clients yet and thus is not in active use."),(0,a.kt)("p",null,"All known malleability concerns have been addressed in the current implementation of ",(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_DIRECT"),".\nThe only known malleability that could occur with a transaction signed with ",(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_DIRECT")," would\nneed to be in the signature bytes themselves.\nSince signatures are not signed over, it is impossible for any sign mode to address this directly\nand instead signature algorithms need to take care to reject any non-canonically encoded signature bytes\nto prevent malleability.\nFor the known malleability of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Multisignature")," type, we should make sure that any valid signatures\nwere encoded following canonical ADR 027 rules when doing signature verification."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_DIRECT_AUX")," provides the same level of safety as ",(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_DIRECT")," because"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"the raw encoded ",(0,a.kt)("inlineCode",{parentName:"li"},"TxBody")," bytes are signed over in ",(0,a.kt)("inlineCode",{parentName:"li"},"SignDocDirectAux"),", and"),(0,a.kt)("li",{parentName:"ul"},"a transaction using ",(0,a.kt)("inlineCode",{parentName:"li"},"SIGN_MODE_DIRECT_AUX")," still requires the primary signer to sign the transaction with ",(0,a.kt)("inlineCode",{parentName:"li"},"SIGN_MODE_DIRECT"))),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_TEXTUAL")," also provides the same level of safety as ",(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_DIRECT")," because the hash of the raw encoded\n",(0,a.kt)("inlineCode",{parentName:"p"},"TxBody")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"AuthInfo")," bytes are signed over."),(0,a.kt)("p",null,"Unfortunately, the vast majority of unaddressed malleability risks affect ",(0,a.kt)("inlineCode",{parentName:"p"},"SIGN_MODE_LEGACY_AMINO_JSON")," and this\nsign mode is still commonly used.\nIt is recommended that the following improvements be made to Amino JSON signing:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"hashes of ",(0,a.kt)("inlineCode",{parentName:"li"},"TxBody")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"AuthInfo")," should be added to ",(0,a.kt)("inlineCode",{parentName:"li"},"AminoSignDoc")," so that encoding-level malleability is addressed"),(0,a.kt)("li",{parentName:"ul"},"when constructing ",(0,a.kt)("inlineCode",{parentName:"li"},"AminoSignDoc"),", ",(0,a.kt)("a",{parentName:"li",href:"https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect"},"protoreflect")," API should be used to ensure that there are no fields in ",(0,a.kt)("inlineCode",{parentName:"li"},"TxBody")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"AuthInfo")," which do not have a mapping in ",(0,a.kt)("inlineCode",{parentName:"li"},"AminoSignDoc")," have been set"),(0,a.kt)("li",{parentName:"ul"},"fields present in ",(0,a.kt)("inlineCode",{parentName:"li"},"TxBody")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"AuthInfo")," that are not present in ",(0,a.kt)("inlineCode",{parentName:"li"},"AminoSignDoc")," (such as extension options) should\nbe added to ",(0,a.kt)("inlineCode",{parentName:"li"},"AminoSignDoc")," if possible")),(0,a.kt)("h2",{id:"testing"},"Testing"),(0,a.kt)("p",null,"To test that transactions are resistant to malleability,\nwe can develop a test suite to run against all sign modes that\nattempts to manipulate transaction bytes in the following ways:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"changing protobuf encoding by",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"reordering fields"),(0,a.kt)("li",{parentName:"ul"},"setting default values"),(0,a.kt)("li",{parentName:"ul"},"adding extra bits to varints, or"),(0,a.kt)("li",{parentName:"ul"},"setting new unknown fields"))),(0,a.kt)("li",{parentName:"ul"},"modifying integer and decimal values encoded as strings with leading or trailing zeros")),(0,a.kt)("p",null,"Whenever any of these manipulations is done, we should observe that the sign doc bytes for the sign mode being\ntested also change, meaning that the corresponding signatures will also have to change."),(0,a.kt)("p",null,"In the case of Amino JSON, we should also develop tests which ensure that if any ",(0,a.kt)("inlineCode",{parentName:"p"},"TxBody")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"AuthInfo"),"\nfield not supported by Amino's ",(0,a.kt)("inlineCode",{parentName:"p"},"AminoSignDoc")," is set that signing fails."),(0,a.kt)("p",null,"In the general case of transaction decoding, we should have unit tests to ensure that"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"any ",(0,a.kt)("inlineCode",{parentName:"li"},"TxRaw")," bytes which do not follow ADR 027 canonical encoding cause decoding to fail, and"),(0,a.kt)("li",{parentName:"ul"},"any top-level transaction elements including ",(0,a.kt)("inlineCode",{parentName:"li"},"TxBody"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"AuthInfo"),", public keys, and messages which\nhave unknown fields set cause the transaction to be rejected\n(this ensures that ADR 020 unknown field filtering is properly applied)")),(0,a.kt)("p",null,"For each supported signature algorithm,\nthere should also be unit tests to ensure that signatures must be encoded canonically\nor get rejected."),(0,a.kt)("h2",{id:"references"},"References"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cosmos/cosmos-sdk/blob/main/docs/architecture/adr-027-deterministic-protobuf-serialization.md"},"ADR 027: Deterministic Protobuf Serialization")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cosmos/cosmos-sdk/blob/main/docs/architecture/adr-020-protobuf-transaction-encoding.md#unknown-field-filtering"},"ADR 020")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"../../x/tx/signing/aminojson/internal/aminojsonpb/aminojson.proto"},(0,a.kt)("inlineCode",{parentName:"a"},"aminojson.proto"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"../../proto/cosmos/tx/v1beta1/tx.proto"},(0,a.kt)("inlineCode",{parentName:"a"},"tx.proto")))))}m.isMDXComponent=!0}}]);