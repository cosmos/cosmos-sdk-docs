"use strict";(self.webpackChunkcosmos_sdk_docs=self.webpackChunkcosmos_sdk_docs||[]).push([[53756],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>m});var o=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=o.createContext({}),p=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},c=function(e){var n=p(e.components);return o.createElement(l.Provider,{value:n},e.children)},d="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},u=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(t),u=r,m=d["".concat(l,".").concat(u)]||d[u]||g[u]||i;return t?o.createElement(m,a(a({ref:n},c),{},{components:t})):o.createElement(m,a({ref:n},c))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,a=new Array(i);a[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[d]="string"==typeof e?e:r,a[1]=s;for(var p=2;p<i;p++)a[p]=t[p];return o.createElement.apply(null,a)}return o.createElement.apply(null,t)}u.displayName="MDXCreateElement"},62728:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>g,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var o=t(87462),r=(t(67294),t(3905));const i={},a="Mitigating Front-running with Vote Extensions",s={unversionedId:"tutorials/vote-extensions/auction-frontrunning/mitigating-front-running-with-vote-extensions",id:"tutorials/vote-extensions/auction-frontrunning/mitigating-front-running-with-vote-extensions",title:"Mitigating Front-running with Vote Extensions",description:"Table of Contents",source:"@site/docs/tutorials/vote-extensions/auction-frontrunning/02-mitigating-front-running-with-vote-extensions.md",sourceDirName:"tutorials/vote-extensions/auction-frontrunning",slug:"/tutorials/vote-extensions/auction-frontrunning/mitigating-front-running-with-vote-extensions",permalink:"/main/tutorials/vote-extensions/auction-frontrunning/mitigating-front-running-with-vote-extensions",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialsSidebar",previous:{title:"Understanding Front-Running and more",permalink:"/main/tutorials/vote-extensions/auction-frontrunning/understanding-frontrunning"},next:{title:"Mitigating Front-running with Vote Extensions",permalink:"/main/tutorials/vote-extensions/auction-frontrunning/mitigating-front-running-with-vote-extesions"}},l={},p=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Implementing Structs for Vote Extensions",id:"implementing-structs-for-vote-extensions",level:3},{value:"Implementing Handlers and Configuring Handlers",id:"implementing-handlers-and-configuring-handlers",level:3}],c={toc:p},d="wrapper";function g(e){let{components:n,...t}=e;return(0,r.kt)(d,(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"mitigating-front-running-with-vote-extensions"},"Mitigating Front-running with Vote Extensions"),(0,r.kt)("h2",{id:"table-of-contents"},"Table of Contents"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#prerequisites"},"Prerequisites")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#implementing-structs-for-vote-extensions"},"Implementing Structs for Vote Extensions")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#implementing-handlers-and-configuring-handlers"},"Implementing Handlers and Configuring Handlers"))),(0,r.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,r.kt)("p",null,"Before implementing vote extensions to mitigate front-running, ensure you have a module ready to implement the vote extensions with. If you need to create or reference a similar module, see ",(0,r.kt)("inlineCode",{parentName:"p"},"x/auction")," for guidance."),(0,r.kt)("p",null,"In this section, we will discuss the steps to mitigate front-running using vote extensions. We will introduce new types within the ",(0,r.kt)("inlineCode",{parentName:"p"},"abci/types.go")," file. These types will be used to handle the process of preparing proposals, processing proposals, and handling vote extensions."),(0,r.kt)("h3",{id:"implementing-structs-for-vote-extensions"},"Implementing Structs for Vote Extensions"),(0,r.kt)("p",null,"First, copy the following structs into the ",(0,r.kt)("inlineCode",{parentName:"p"},"abci/types.go")," and each of these structs serves a specific purpose in the process of mitigating front-running using vote extensions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"package abci\n\nimport (\n //import the necessary files\n)\n\ntype PrepareProposalHandler struct {\n logger      log.Logger\n txConfig    client.TxConfig\n cdc         codec.Codec\n mempool     *mempool.ThresholdMempool\n txProvider  provider.TxProvider\n keyname     string\n runProvider bool\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"PrepareProposalHandler")," struct is used to handle the preparation of a proposal in the consensus process. It contains several fields: logger for logging information and errors, txConfig for transaction configuration, cdc (Codec) for encoding and decoding transactions, mempool for referencing the set of unconfirmed transactions, txProvider for building the proposal with transactions, keyname for the name of the key used for signing transactions, and runProvider, a boolean flag indicating whether the provider should be run to build the proposal."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type ProcessProposalHandler struct {\n TxConfig client.TxConfig\n Codec    codec.Codec\n Logger   log.Logger\n}\n")),(0,r.kt)("p",null,"After the proposal has been prepared and vote extensions have been included, the ",(0,r.kt)("inlineCode",{parentName:"p"},"ProcessProposalHandler")," is used to process the proposal. This includes validating the proposal and the included vote extensions. The ",(0,r.kt)("inlineCode",{parentName:"p"},"ProcessProposalHandler")," allows you to access the transaction configuration and codec, which are necessary for processing the vote extensions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type VoteExtHandler struct {\n logger       log.Logger\n currentBlock int64\n mempool      *mempool.ThresholdMempool\n cdc          codec.Codec\n}\n")),(0,r.kt)("p",null,"This struct is used to handle vote extensions. It contains a logger for logging events, the current block number, a mempool for storing transactions, and a codec for encoding and decoding. Vote extensions are a key part of the process to mitigate front-running, as they allow for additional information to be included with each vote."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type InjectedVoteExt struct {\n VoteExtSigner []byte\n Bids          [][]byte\n}\n\ntype InjectedVotes struct {\n Votes []InjectedVoteExt\n}\n")),(0,r.kt)("p",null,"These structs are used to handle injected vote extensions. They include the signer of the vote extension and the bids associated with the vote extension. Each byte array in Bids is a serialised form of a bid transaction. Injected vote extensions are used to add additional information to a vote after it has been created, which can be useful for adding context or additional data to a vote. The serialised bid transactions provide a way to include complex transaction data in a compact, efficient format."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type AppVoteExtension struct {\n Height int64\n Bids   [][]byte\n}\n")),(0,r.kt)("p",null,"This struct is used for application vote extensions. It includes the height of the block and the bids associated with the vote extension. Application vote extensions are used to add additional information to a vote at the application level, which can be useful for adding context or additional data to a vote that is specific to the application."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type SpecialTransaction struct {\n Height int\n Bids   [][]byte\n}\n")),(0,r.kt)("p",null,"This struct is used for special transactions. It includes the height of the block and the bids associated with the transaction. Special transactions are used for transactions that need to be handled differently from regular transactions, such as transactions that are part of the process to mitigate front-running."),(0,r.kt)("h3",{id:"implementing-handlers-and-configuring-handlers"},"Implementing Handlers and Configuring Handlers"),(0,r.kt)("p",null,"To establish the ",(0,r.kt)("inlineCode",{parentName:"p"},"VoteExtensionHandler"),", follow these steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Navigate to the ",(0,r.kt)("inlineCode",{parentName:"p"},"abci/proposal.go")," file. This is where we will implement the `VoteExtensionHandler``.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"NewVoteExtensionHandler")," function. This function is a constructor for the ",(0,r.kt)("inlineCode",{parentName:"p"},"VoteExtHandler")," struct. It takes a logger, a mempool, and a codec as parameters and returns a new instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"VoteExtHandler"),"."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func NewVoteExtensionHandler(lg log.Logger, mp *mempool.ThresholdMempool, cdc codec.Codec) *VoteExtHandler {  \n   return &VoteExtHandler{  \n      logger:  lg,  \n      mempool: mp,  \n      cdc:     cdc,  \n   }  \n}\n")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"Implement the ",(0,r.kt)("inlineCode",{parentName:"li"},"ExtendVoteHandler()")," method. This method should handle the logic of extending votes, including inspecting the mempool and submitting a list of all pending bids. This will allow you to access the list of unconfirmed transactions in the abci.",(0,r.kt)("inlineCode",{parentName:"li"},"RequestPrepareProposal")," during the ensuing block.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func (h *VoteExtHandler) ExtendVoteHandler() sdk.ExtendVoteHandler {\n return func(ctx sdk.Context, req *abci.RequestExtendVote) (*abci.ResponseExtendVote, error) {\n      h.logger.Info(fmt.Sprintf("Extending votes at block height : %v", req.Height))\n\n voteExtBids := [][]byte{}\n\n // Get mempool txs\n itr := h.mempool.SelectPending(context.Background(), nil)\n for itr != nil {\n  tmptx := itr.Tx()\n  sdkMsgs := tmptx.GetMsgs()\n\n  // Iterate through msgs, check for any bids\n  for _, msg := range sdkMsgs {\n   switch msg := msg.(type) {\n   case *nstypes.MsgBid:\n   // Marshal sdk bids to []byte\n    bz, err := h.cdc.Marshal(msg)\n    if err != nil {\n     h.logger.Error(fmt.Sprintf("Error marshalling VE Bid : %v", err))\n     break\n    }\n    voteExtBids = append(voteExtBids, bz)\n   default:\n   }\n  }\n\n  // Move tx to ready pool\n  err := h.mempool.Update(context.Background(), tmptx)\n  \n  // Remove tx from app side mempool\n  if err != nil {\n   h.logger.Info(fmt.Sprintf("Unable to update mempool tx: %v", err))\n  }\n  \n  itr = itr.Next()\n }\n\n // Create vote extension\n voteExt := AppVoteExtension{\n Height: req.Height,\n Bids: voteExtBids,\n }\n\n // Encode Vote Extension\n bz, err := json.Marshal(voteExt)\n  if err != nil {\n  return nil, fmt.Errorf("Error marshalling VE: %w", err)\n }\n\n return &abci.ResponseExtendVote{VoteExtension: bz}, nil\n}\n')),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},"Configure the handler in ",(0,r.kt)("inlineCode",{parentName:"li"},"app/app.go")," as shown below")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"bApp := baseapp.NewBaseApp(AppName, logger, db, txConfig.TxDecoder(), baseAppOptions...)\nvoteExtHandler := abci2.NewVoteExtensionHandler(logger, mempool, appCodec)\nbApp.SetExtendVoteHandler(voteExtHandler.ExtendVoteHandler())\n")),(0,r.kt)("p",null,"To give a bit of context on what is happening above, we first create a new instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"VoteExtensionHandler")," with the necessary dependencies (logger, mempool, and codec). Then, we set this handler as the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExtendVoteHandler")," for our application. This means that whenever a vote needs to be extended, our custom ",(0,r.kt)("inlineCode",{parentName:"p"},"ExtendVoteHandler()")," method will be called."),(0,r.kt)("p",null,"To test if vote extensions have been propagated, add the following to the ",(0,r.kt)("inlineCode",{parentName:"p"},"PrepareProposalHandler"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'if req.Height > 2 {  \n   voteExt := req.GetLocalLastCommit()  \n   h.logger.Info(fmt.Sprintf("\ud83d\udee0\ufe0f :: Get vote extensions: %v", voteExt))  \n}\n')),(0,r.kt)("p",null,"This is how the whole function should look:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func (h *PrepareProposalHandler) PrepareProposalHandler() sdk.PrepareProposalHandler {\n return func(ctx sdk.Context, req *abci.RequestPrepareProposal) (*abci.ResponsePrepareProposal, error) {\n  h.logger.Info(fmt.Sprintf("\ud83d\udee0\ufe0f :: Prepare Proposal"))\n  var proposalTxs [][]byte\n\n  var txs []sdk.Tx\n\n  // Get Vote Extensions\n  if req.Height > 2 {\n   voteExt := req.GetLocalLastCommit()\n   h.logger.Info(fmt.Sprintf("\ud83d\udee0\ufe0f :: Get vote extensions: %v", voteExt))\n  }\n\n  itr := h.mempool.Select(context.Background(), nil)\n  for itr != nil {\n   tmptx := itr.Tx()\n\n   txs = append(txs, tmptx)\n   itr = itr.Next()\n  }\n  h.logger.Info(fmt.Sprintf("\ud83d\udee0\ufe0f :: Number of Transactions available from mempool: %v", len(txs)))\n\n  if h.runProvider {\n   tmpMsgs, err := h.txProvider.BuildProposal(ctx, txs)\n   if err != nil {\n    h.logger.Error(fmt.Sprintf("\u274c\ufe0f :: Error Building Custom Proposal: %v", err))\n   }\n   txs = tmpMsgs\n  }\n\n  for _, sdkTxs := range txs {\n   txBytes, err := h.txConfig.TxEncoder()(sdkTxs)\n   if err != nil {\n    h.logger.Info(fmt.Sprintf("\u274c~Error encoding transaction: %v", err.Error()))\n   }\n   proposalTxs = append(proposalTxs, txBytes)\n  }\n\n  h.logger.Info(fmt.Sprintf("\ud83d\udee0\ufe0f :: Number of Transactions in proposal: %v", len(proposalTxs)))\n\n  return &abci.ResponsePrepareProposal{Txs: proposalTxs}, nil\n }\n}\n')),(0,r.kt)("p",null,"As mentioned above, we check if vote extensions have been propagated, you can do this by checking the logs for any relevant messages such as ",(0,r.kt)("inlineCode",{parentName:"p"},"\ud83d\udee0\ufe0f :: Get vote extensions:"),". If the logs do not provide enough information, you can also reinitialise your local testing environment by running the ",(0,r.kt)("inlineCode",{parentName:"p"},"./scripts/single_node/setup.sh")," script again."),(0,r.kt)("ol",{start:5},(0,r.kt)("li",{parentName:"ol"},"Implement the ",(0,r.kt)("inlineCode",{parentName:"li"},"ProcessProposalHandler()"),". This function is responsible for processing the proposal. It should handle the logic of processing vote extensions, including inspecting the proposal and validating the bids.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func (h *ProcessProposalHandler) ProcessProposalHandler() sdk.ProcessProposalHandler {\n return func(ctx sdk.Context, req *abci.RequestProcessProposal) (resp *abci.ResponseProcessProposal, err error) {\n  h.Logger.Info(fmt.Sprintf("\u2699\ufe0f :: Process Proposal"))\n\n  // The first transaction will always be the Special Transaction\n  numTxs := len(req.Txs)\n\n  h.Logger.Info(fmt.Sprintf("\u2699\ufe0f:: Number of transactions :: %v", numTxs))\n\n  if numTxs >= 1 {\n   var st SpecialTransaction\n   err = json.Unmarshal(req.Txs[0], &st)\n   if err != nil {\n    h.Logger.Error(fmt.Sprintf("\u274c\ufe0f:: Error unmarshalling special Tx in Process Proposal :: %v", err))\n   }\n   if len(st.Bids) > 0 {\n    h.Logger.Info(fmt.Sprintf("\u2699\ufe0f:: There are bids in the Special Transaction"))\n    var bids []nstypes.MsgBid\n    for i, b := range st.Bids {\n     var bid nstypes.MsgBid\n     h.Codec.Unmarshal(b, &bid)\n     h.Logger.Info(fmt.Sprintf("\u2699\ufe0f:: Special Transaction Bid No %v :: %v", i, bid))\n     bids = append(bids, bid)\n    }\n    // Validate Bids in Tx\n    txs := req.Txs[1:]\n    ok, err := ValidateBids(h.TxConfig, bids, txs, h.Logger)\n    if err != nil {\n     h.Logger.Error(fmt.Sprintf("\u274c\ufe0f:: Error validating bids in Process Proposal :: %v", err))\n     return &abci.ResponseProcessProposal{Status: abci.ResponseProcessProposal_REJECT}, nil\n    }\n    if !ok {\n     h.Logger.Error(fmt.Sprintf("\u274c\ufe0f:: Unable to validate bids in Process Proposal :: %v", err))\n     return &abci.ResponseProcessProposal{Status: abci.ResponseProcessProposal_REJECT}, nil\n    }\n    h.Logger.Info("\u2699\ufe0f:: Successfully validated bids in Process Proposal")\n   }\n  }\n\n  return &abci.ResponseProcessProposal{Status: abci.ResponseProcessProposal_ACCEPT}, nil\n }\n}\n')),(0,r.kt)("ol",{start:6},(0,r.kt)("li",{parentName:"ol"},"Implement the ",(0,r.kt)("inlineCode",{parentName:"li"},"ProcessVoteExtensions()")," function. This function should handle the logic of processing vote extensions, including validating the bids.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func processVoteExtensions(req *abci.RequestPrepareProposal, log log.Logger) (SpecialTransaction, error) {\n log.Info(fmt.Sprintf("\ud83d\udee0\ufe0f :: Process Vote Extensions"))\n\n // Create empty response\n st := SpecialTransaction{\n  0,\n  [][]byte{},\n }\n\n // Get Vote Ext for H-1 from Req\n voteExt := req.GetLocalLastCommit()\n votes := voteExt.Votes\n\n // Iterate through votes\n var ve AppVoteExtension\n for _, vote := range votes {\n  // Unmarshal to AppExt\n  err := json.Unmarshal(vote.VoteExtension, &ve)\n  if err != nil {\n   log.Error(fmt.Sprintf("\u274c :: Error unmarshalling Vote Extension"))\n  }\n\n  st.Height = int(ve.Height)\n\n  // If Bids in VE, append to Special Transaction\n  if len(ve.Bids) > 0 {\n   log.Info("\ud83d\udee0\ufe0f :: Bids in VE")\n   for _, b := range ve.Bids {\n    st.Bids = append(st.Bids, b)\n   }\n  }\n }\n\n return st, nil\n}\n')),(0,r.kt)("ol",{start:7},(0,r.kt)("li",{parentName:"ol"},"Configure the ",(0,r.kt)("inlineCode",{parentName:"li"},"ProcessProposalHandler()")," in app/app.go:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"processPropHandler := abci2.ProcessProposalHandler{app.txConfig, appCodec, logger}\nbApp.SetProcessProposal(processPropHandler.ProcessProposalHandler())\n")),(0,r.kt)("p",null,"This sets the ",(0,r.kt)("inlineCode",{parentName:"p"},"ProcessProposalHandler()")," for our application. This means that whenever a proposal needs to be processed, our custom ",(0,r.kt)("inlineCode",{parentName:"p"},"ProcessProposalHandler()")," method will be called."),(0,r.kt)("p",null,"To test if the proposal processing and vote extensions are working correctly, you can check the logs for any relevant messages. If the logs do not provide enough information, you can also reinitialize your local testing environment by running ",(0,r.kt)("inlineCode",{parentName:"p"},"./scripts/single_node/setup.sh")," script."))}g.isMDXComponent=!0}}]);