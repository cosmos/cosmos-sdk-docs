"use strict";(self.webpackChunkcosmos_sdk_docs=self.webpackChunkcosmos_sdk_docs||[]).push([[28910],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var r=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function n(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,r,i=function(e,t){if(null==e)return{};var a,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=r.createContext({}),d=function(e){var t=r.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):n(n({},t),e)),a},p=function(e){var t=d(e.components);return r.createElement(l.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=d(a),u=i,h=c["".concat(l,".").concat(u)]||c[u]||m[u]||o;return a?r.createElement(h,n(n({ref:t},p),{},{components:a})):r.createElement(h,n({ref:t},p))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,n=new Array(o);n[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:i,n[1]=s;for(var d=2;d<o;d++)n[d]=a[d];return r.createElement.apply(null,n)}return r.createElement.apply(null,a)}u.displayName="MDXCreateElement"},92761:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>n,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var r=a(87462),i=(a(67294),a(3905));const o={sidebar_position:1},n="Store",s={unversionedId:"learn/advanced/store",id:"version-0.47/learn/advanced/store",title:"Store",description:"A store is a data structure that holds the state of the application.",source:"@site/versioned_docs/version-0.47/learn/advanced/04-store.md",sourceDirName:"learn/advanced",slug:"/learn/advanced/store",permalink:"/v0.47/learn/advanced/store",draft:!1,tags:[],version:"0.47",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"learnSidebar",previous:{title:"Node Client (Daemon)",permalink:"/v0.47/learn/advanced/node"},next:{title:"Inter-block Cache",permalink:"/v0.47/learn/advanced/interblock-cache"}},l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Multistore",id:"multistore",level:2},{value:"Store Interfaces",id:"store-interfaces",level:2},{value:"KVStore",id:"kvstore",level:3},{value:"CommitKVStore",id:"commitkvstore",level:3},{value:"StoreDB",id:"storedb",level:3},{value:"DBAdapter",id:"dbadapter",level:3},{value:"TransientStore",id:"transientstore",level:3},{value:"Store Abstractions",id:"store-abstractions",level:2},{value:"CacheWrap",id:"cachewrap",level:3},{value:"HistoryStore",id:"historystore",level:3},{value:"IndexStore",id:"indexstore",level:3},{value:"Queryable",id:"queryable",level:3},{value:"PrefixIterator",id:"prefixiterator",level:3},{value:"RootMultiStore",id:"rootmultistore",level:3},{value:"GasKVStore",id:"gaskvstore",level:3},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Store Migration",id:"store-migration",level:2}],p={toc:d},c="wrapper";function m(e){let{components:t,...a}=e;return(0,i.kt)(c,(0,r.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"store"},"Store"),(0,i.kt)("admonition",{title:"Synopsis",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"A store is a data structure that holds the state of the application.")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("h3",{parentName:"admonition",id:"pre-requisite-readings"},"Pre-requisite Readings"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/v0.47/learn/beginner/overview-app"},"Anatomy of a Cosmos SDK application")))),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"The Cosmos SDK store package provides interfaces, types, and abstractions for managing Merkleized state storage and commitment within a Cosmos SDK application. The package supplies various primitives for developers to work with, including state storage, state commitment, and wrapper KVStores. This document highlights the key abstractions and their significance."),(0,i.kt)("h2",{id:"multistore"},"Multistore"),(0,i.kt)("p",null,"The main store in Cosmos SDK applications is a multistore, a store of stores, that supports modularity. Developers can add any number of key-value stores to the multistore based on their application needs. Each module can declare and manage its own subset of the state, allowing for a modular approach. Key-value stores within the multistore can only be accessed with a specific capability key, which is typically held in the keeper of the module that declared the store."),(0,i.kt)("h2",{id:"store-interfaces"},"Store Interfaces"),(0,i.kt)("h3",{id:"kvstore"},"KVStore"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"KVStore")," interface defines a key-value store that can be used to store and retrieve data. The default implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"KVStore")," used in ",(0,i.kt)("inlineCode",{parentName:"p"},"baseapp")," is the ",(0,i.kt)("inlineCode",{parentName:"p"},"iavl.Store"),", which is based on an IAVL Tree. KVStores can be accessed by objects that hold a specific key and can provide an ",(0,i.kt)("inlineCode",{parentName:"p"},"Iterator")," method that returns an ",(0,i.kt)("inlineCode",{parentName:"p"},"Iterator")," object, used to iterate over a range of keys."),(0,i.kt)("h3",{id:"commitkvstore"},"CommitKVStore"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"CommitKVStore")," interface extends the ",(0,i.kt)("inlineCode",{parentName:"p"},"KVStore")," interface and adds methods for state commitment. The default implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"CommitKVStore")," used in ",(0,i.kt)("inlineCode",{parentName:"p"},"baseapp")," is also the ",(0,i.kt)("inlineCode",{parentName:"p"},"iavl.Store"),"."),(0,i.kt)("h3",{id:"storedb"},"StoreDB"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"StoreDB")," interface defines a database that can be used to persist key-value stores. The default implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"StoreDB")," used in ",(0,i.kt)("inlineCode",{parentName:"p"},"baseapp")," is the ",(0,i.kt)("inlineCode",{parentName:"p"},"dbm.DB"),", which is a simple persistent key-value store."),(0,i.kt)("h3",{id:"dbadapter"},"DBAdapter"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"DBAdapter")," interface defines an adapter for ",(0,i.kt)("inlineCode",{parentName:"p"},"dbm.DB")," that fulfills the ",(0,i.kt)("inlineCode",{parentName:"p"},"KVStore")," interface. This interface is used to provide compatibility between the ",(0,i.kt)("inlineCode",{parentName:"p"},"dbm.DB")," implementation and the ",(0,i.kt)("inlineCode",{parentName:"p"},"KVStore")," interface."),(0,i.kt)("h3",{id:"transientstore"},"TransientStore"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"TransientStore")," interface defines a base-layer KVStore which is automatically discarded at the end of the block and is useful for persisting information that is only relevant per-block, like storing parameter changes."),(0,i.kt)("h2",{id:"store-abstractions"},"Store Abstractions"),(0,i.kt)("p",null,"The store package provides a comprehensive set of abstractions for managing state commitment and storage in an SDK application. These abstractions include CacheWrapping, KVStore, and CommitMultiStore, which offer a range of features such as CRUD functionality, prefix-based iteration, and state commitment management."),(0,i.kt)("p",null,"By utilizing these abstractions, developers can create modular applications with independent state management for each module. This approach allows for a more organized and maintainable application structure."),(0,i.kt)("h3",{id:"cachewrap"},"CacheWrap"),(0,i.kt)("p",null,"CacheWrap is a wrapper around a KVStore that provides caching for both read and write operations. The CacheWrap can be used to improve performance by reducing the number of disk reads and writes required for state storage operations. The CacheWrap also includes a Write method that commits the pending writes to the underlying KVStore."),(0,i.kt)("h3",{id:"historystore"},"HistoryStore"),(0,i.kt)("p",null,"The HistoryStore is an optional feature that can be used to store historical versions of the state. The HistoryStore can be used to track changes to the state over time, allowing developers to analyze changes in the state and roll back to previous versions if necessary."),(0,i.kt)("h3",{id:"indexstore"},"IndexStore"),(0,i.kt)("p",null,"The IndexStore is a type of KVStore that is used to maintain indexes of data stored in other KVStores. IndexStores can be used to improve query performance by providing a way to quickly search for data based on specific criteria."),(0,i.kt)("h3",{id:"queryable"},"Queryable"),(0,i.kt)("p",null,"The Queryable interface is used to provide a way for applications to query the state stored in a KVStore. The Queryable interface includes methods for retrieving data based on a key or a range of keys, as well as methods for retrieving data based on specific criteria."),(0,i.kt)("h3",{id:"prefixiterator"},"PrefixIterator"),(0,i.kt)("p",null,"The PrefixIterator interface is used to iterate over a range of keys in a KVStore that share a common prefix. PrefixIterators can be used to efficiently retrieve subsets of data from a KVStore based on a specific prefix."),(0,i.kt)("h3",{id:"rootmultistore"},"RootMultiStore"),(0,i.kt)("p",null,"The RootMultiStore is a Multistore that provides the ability to retrieve a snapshot of the state at a specific height. This is useful for implementing light clients."),(0,i.kt)("h3",{id:"gaskvstore"},"GasKVStore"),(0,i.kt)("p",null,"The GasKVStore is a wrapper around a KVStore that provides gas measurement for read and write operations. The GasKVStore is typically used to measure the cost of executing transactions."),(0,i.kt)("h2",{id:"implementation-details"},"Implementation Details"),(0,i.kt)("p",null,"While there are many interfaces that the store package provides, there is typically a core implementation for each main interface that modules and developers interact with that are defined in the Cosmos SDK."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"iavl.Store")," provides the core implementation for state storage and commitment by implementing the following interfaces:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"KVStore")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CommitStore")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CommitKVStore")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Queryable")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"StoreWithInitialVersion"))),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"iavl.Store")," also provides the ability to remove historical state from the state commitment layer."),(0,i.kt)("p",null,"An overview of the IAVL implementation can be found ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cosmos/iavl/blob/master/docs/overview.md"},"here"),"."),(0,i.kt)("p",null,"Other store abstractions include ",(0,i.kt)("inlineCode",{parentName:"p"},"cachekv.Store"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"gaskv.Store"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"cachemulti.Store"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"rootmulti.Store"),". Each of these stores provide additional functionality and abstractions for developers to work with."),(0,i.kt)("p",null,"Note that concurrent access to the ",(0,i.kt)("inlineCode",{parentName:"p"},"iavl.Store")," tree is not safe, and it is the responsibility of the caller to ensure that concurrent access to the store is not performed."),(0,i.kt)("h2",{id:"store-migration"},"Store Migration"),(0,i.kt)("p",null,"Store migration is the process of updating the structure of a KVStore to support new features or changes in the data model. Store migration can be a complex process, but it is essential for maintaining the integrity of the state stored in a KVStore."))}m.isMDXComponent=!0}}]);